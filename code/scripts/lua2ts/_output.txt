if ( Items == null ) {
	Items = class({})
}

//  检测物品
CHECK_ITEM_RESULT_SUCCESS = 0 //  成功
CHECK_ITEM_RESULT_FAIL_FALSE_OWNER = 1 //  失败，其他玩家的物品
CHECK_ITEM_RESULT_FAIL_EXCLUSIVE = 2 //  失败，不是你的专属

//  TODO:成员函数区分客户端服务端
 init(bReload) {
	this.InitKV()
	if ( IsServer() ) {
		if ( !bReload ) {
			this.InitPublicArea()
			this.tCustomBackPack = {} //  背包
			this.tPublicBackPack = {} //  公共背包
			this.tItemProperties = {} //  六星装备对应的额外属性
		}

		CustomUIEvent("QuickuseConsumable", Dynamic_Wrap(Items, "OnQuickuseConsumable"), Items)
		CustomUIEvent("CustomRemakeItem", Dynamic_Wrap(Items, "OnCustomRemakeItem"), Items)
		Request.Event("CombineItem", Dynamic_Wrap(Items, "OnCombineItem"), Items)
		CustomUIEvent("CombineItem_lv6", Dynamic_Wrap(Items, "OnCombineItem_lv6"), Items)

		GameEvent("custom_npc_first_spawned", Dynamic_Wrap(Items, "OnNPCFirstSpawned"), Items)
		GameEvent("custom_entity_removed", Dynamic_Wrap(Items, "OnEntityRemoved"), Items)
	}

	GameEvent("custom_inventory_contents_changed", Dynamic_Wrap(Items, "OnInventoryContentsChanged"), Items)
}
//  重铸相关的信息
 InitKV() {
	this.tRemakeGroups = {} //  { [sGroup] : { [sItemName]: 1 } }
	this.tRemakeItem2Group = {} //  { [sItemName] : sGroup }
	//  不可同时装备同组装备
	this.tItem2EquipGroup = {} //  { [sItemName] : sGroup }
	this.tEquipGroups = {}
	for (let v of ( KeyValues.ItemsKv)) {
	 

		if ( sItemName != "Version" ) {
			if ( v.RemakeGroup ) {
				let sGroup = v.RemakeGroup
				if ( sGroup == "upgradable_items" ) {
					for i = (v.ItemBaseLevel || 1), (v.MaxUpgradeLevel || 1) do
						let sGroupLevel = sGroup + i
						let sItemLevel = sItemName + "," + i
						if ( this.tRemakeGroups[sGroupLevel] == null ) {
							this.tRemakeGroups[sGroupLevel] = {}
						}
						this.tRemakeGroups[sGroupLevel][sItemLevel] = 1
						//  this.tRemakeItem2Group[sItemLevel] = sGroupLevel
					}
				} else {
					if ( this.tRemakeGroups[sGroup] == null ) {
						this.tRemakeGroups[sGroup] = {}
					}
					this.tRemakeGroups[sGroup][sItemName] = 1
					this.tRemakeItem2Group[sItemName] = sGroup
				}
			}
			if ( v.EquipGroup ) {
				let sGroup = v.EquipGroup
				if ( this.tEquipGroups[sGroup] == null ) {
					this.tEquipGroups[sGroup] = {}
				}
				this.tEquipGroups[sGroup][sItemName] = 1
				this.tItem2EquipGroup[sItemName] = sGroup
			}
		}
	}
	if ( IsServer() ) {
		//  DeepPrintTable(this.tRemakeGroups)
		//  DeepPrintTable(this.tRemakeItem2Group)
	}
}
 InitPublicArea() {
	this.tPublicArea = {}
	let public_warehouses = Entities.FindAllByName("public_warehouse")
	for (let public_warehouse of ( public_warehouses)) {
	 

		let origin = public_warehouse.GetAbsOrigin()
		let angles = public_warehouse.GetAngles()
		let bounds = public_warehouse.GetBounds()
		let vMin = RotatePosition(Vector(0, 0, 0), angles, bounds.Mins) + origin
		let vMax = RotatePosition(Vector(0, 0, 0), angles, bounds.Maxs) + origin

		table.insert(this.tPublicArea, {
			Vector(vMin.x, vMin.y, vMax.z),
			Vector(vMax.x, vMin.y, vMax.z),
			Vector(vMax.x, vMax.y, vMax.z),
			Vector(vMin.x, vMax.y, vMax.z)
		})

		CustomNetTables.SetTableValue("common", "sharing_area", this.tPublicArea)
	}
}
// // // // // // // // // // // // // // // // // // // -nettable// // // // // // // // // // // // // // // // // // // -
if ( IsServer() ) {
	 UpdateBackPackNettable(iPlayerID, islot) {
		CustomNetTables.SetTableValue("common", "back_pack", this.tCustomBackPack)
		CustomNetTables.SetTableValue("common", "public_back_pack", this.tPublicBackPack)
		//  DeepPrintTable(this.tCustomBackPack[0])
	}
}
// // // // // // // // // // // // // // // // // // // -背包// // // // // // // // // // // // // // // // // // // -
if ( IsServer() ) {
	// - 尝试将一个物品放到空的自定义背包格
	 TryMoveEmptyBackPack(iPlayerID, hUnit, hItem) {
		if ( type(this.tCustomBackPack[iPlayerID]) == "table" ) {
			for (let iSlot = CUSTOM_ITEM_SLOT_MIN; iSlot <= CUSTOM_COMBINE_SLOT_MIN - 1 ; iSlot++) {
				if ( this.tCustomBackPack[iPlayerID][iSlot] == null ) {
					this.TryMoveBackPack(iPlayerID, hUnit, hItem, iSlot)
					return true
				}
			}
		}
		return false
	}
	// - 尝试将一个物品放到空的合成格
	 TryMoveCombine(iPlayerID, hUnit, hItem) {
		if ( type(this.tCustomBackPack[iPlayerID]) == "table" ) {
			for (let iSlot = CUSTOM_COMBINE_SLOT_MIN; iSlot <= CUSTOM_ITEM_SLOT_MAX ; iSlot++) {
				if ( this.tCustomBackPack[iPlayerID][iSlot] == null ) {
					return this.TryMoveBackPack(iPlayerID, hUnit, hItem, iSlot)
				}
			}
		}
		return false
	}
	// - @param hUnit CDOTA_BaseNPC 目标单位
	 TryMoveInventory(hUnit, hItem) {
		for (let i = DOTA_ITEM_SLOT_1; i <= DOTA_ITEM_SLOT_9 ; i++) {
			let hSlotItem = hUnit.GetItemInSlot(i)
			if ( !GameFunc.IsValid(hSlotItem) ) {
				let result = Items.Inventory2BackPack(hUnit, i, hItem.GetItemSlot_Plus(), false)
				this.UpdateBackPackNettable()
				return result
			}
		}
	}
	// - 尝试将一个物品放到空的公共背包格
	 TryMoveEmptyPublic(iPlayerID, hUnit, hItem) {
		if ( type(this.tPublicBackPack) == "table" ) {
			for (let iSlot = PUBLIC_ITEM_SLOT_MIN; iSlot <= PUBLIC_ITEM_SLOT_MAX ; iSlot++) {
				if ( this.tPublicBackPack[iSlot] == null ) {
					return this.TryMoveBackPack(iPlayerID, hUnit, hItem, iSlot)
				}
			}
		}
		return false
	}
	// - 自定义背包的移动物品操作，不会处理移动双方都在dota2原生物品栏的情况（直接return null）
	// - @param iPlayerID number 发出操作的玩家
	// - @param hUnit CDOTA_BaseNPC 物品在谁身上
	// - @param hItem CDOTA_Item 物品
	// - @return boolean true 表示成功处理
	 TryMoveBackPack(iPlayerID, hUnit, hItem, iTargetSLot) {
		if ( iTargetSLot > PUBLIC_ITEM_SLOT_MAX ) {
			return
		}

		if ( !(GameFunc.IsValid(hUnit) && GameFunc.IsValid(hItem) && type(hItem.GetItemSlot_Plus) == "function") ) {
			return
		}

		if ( type(this.tCustomBackPack[iPlayerID]) != "table" ) {
			this.tCustomBackPack[iPlayerID] = {}
		}

		//  判断物品是在物品栏还是背包
		let iFromSlot = hItem.GetItemSlot_Plus()
		if ( iFromSlot == -1 ) {
			return
		}
		//  不处理移动双方都在dota2原生物品栏的情况
		if ( iFromSlot < CUSTOM_ITEM_SLOT_MIN && iTargetSLot < CUSTOM_ITEM_SLOT_MIN ) {
			return
		}

		if ( !IsInToolsMode() && iFromSlot < PUBLIC_ITEM_SLOT_MIN ) {
			let hItemOwner = hItem.GetPurchaser()
			let iItemOwnerPlayerID = (GameFunc.IsValid(hItemOwner) && hItemOwner.IsAlive()) && hItemOwner.GetPlayerOwnerID() || -1
			if ( iItemOwnerPlayerID != -1 && iPlayerID != iItemOwnerPlayerID ) { //  物品不属于这个玩家
				return
			}
		}

		let result
		//  移动双方都在自定义背包
		if ( iFromSlot >= CUSTOM_ITEM_SLOT_MIN && iTargetSLot >= CUSTOM_ITEM_SLOT_MIN ) {
			result = this.SwapBackPack(iPlayerID, iFromSlot, iTargetSLot)
		} else {
			//  移动双方各占一方
			let iSlotInv = iFromSlot < CUSTOM_ITEM_SLOT_MIN && iFromSlot || iTargetSLot
			let iSlotBP = iFromSlot < CUSTOM_ITEM_SLOT_MIN && iTargetSLot || iFromSlot
			result = this.Inventory2BackPack(hUnit, iSlotInv, iSlotBP, iFromSlot < CUSTOM_ITEM_SLOT_MIN)
			this.tryStackItem(iPlayerID, iSlotBP)
		}

		this.UpdateBackPackNettable()
		return result
	}
	//  两个都在backpack的物品交换位置
	 SwapBackPack(iPlayerID, iFromSlot, iTargetSlot) {
		if ( type(this.tCustomBackPack[iPlayerID]) != "table" ) {
			this.tCustomBackPack[iPlayerID] = {}
		}

		//  两者都在个人背包
		if ( iFromSlot < PUBLIC_ITEM_SLOT_MIN && iTargetSlot < PUBLIC_ITEM_SLOT_MIN ) {
			let temp = this.tCustomBackPack[iPlayerID][iFromSlot]
			this.tCustomBackPack[iPlayerID][iFromSlot] = this.tCustomBackPack[iPlayerID][iTargetSlot]
			this.tCustomBackPack[iPlayerID][iTargetSlot] = temp
			return true
			//  两者都在公共背包
		} else if ( iFromSlot >= PUBLIC_ITEM_SLOT_MIN && iTargetSlot >= PUBLIC_ITEM_SLOT_MIN ) {
			let temp = this.tPublicBackPack[iFromSlot]
			this.tPublicBackPack[iFromSlot] = this.tPublicBackPack[iTargetSlot]
			this.tPublicBackPack[iTargetSlot] = temp
			return true
		} else {
			//  两边都有同名的可叠加物品的情况处理
			let iSlotPersonal = iFromSlot < PUBLIC_ITEM_SLOT_MIN && iFromSlot || iTargetSlot
			let iSlotPublic = iFromSlot < PUBLIC_ITEM_SLOT_MIN && iTargetSlot || iFromSlot
			let hItemPersonal = EntIndexToHScript(this.tCustomBackPack[iPlayerID][iSlotPersonal] || -1)
			let hItemPublic = EntIndexToHScript(this.tPublicBackPack[iSlotPublic] || -1)
			if ( GameFunc.IsValid(hItemPersonal) && !hItemPersonal.IsCustomShareable() ) {
				ErrorMessage(iPlayerID, "dota_hud_error_not_shareable")
				return false
			}
			if ( GameFunc.IsValid(hItemPersonal) && GameFunc.IsValid(hItemPublic) ) {
				let sItemPersonal = hItemPersonal.GetName()
				let sItemPublic = hItemPublic.GetName()
				if ( sItemPersonal == sItemPublic && hItemPersonal.IsStackable() ) {
					let iChargeTotal = hItemPersonal.GetCurrentCharges() + hItemPublic.GetCurrentCharges()
					if ( iFromSlot < PUBLIC_ITEM_SLOT_MIN ) {
						hItemPublic.SetCurrentCharges(iChargeTotal)
						hItemPersonal.Remove()
						this.tCustomBackPack[iPlayerID][iSlotPersonal] = null
						return true
					} else {
						hItemPersonal.SetCurrentCharges(iChargeTotal)
						hItemPublic.Remove()
						this.tPublicBackPack[iSlotPublic] = null
						return true
					}
				}
			}

			let tempPublic = this.tPublicBackPack[iSlotPublic]
			this.tPublicBackPack[iSlotPublic] = this.tCustomBackPack[iPlayerID][iSlotPersonal]
			this.tCustomBackPack[iPlayerID][iSlotPersonal] = tempPublic

			let hHero = PlayerResource.GetSelectedHeroEntity(iPlayerID)
			let hItemOldPublic = EntIndexToHScript(tempPublic || -1)
			let hItemOldPersonal = EntIndexToHScript(this.tPublicBackPack[iSlotPublic] || -1) //  原本在个人背包，现在在公共背包的物品
			//  从公共背包拿到身上的东西要有所属者
			if ( GameFunc.IsValid(hItemOldPublic) ) {
				hItemOldPublic.SetPurchaser(hHero)
				hItemOldPublic.SetOwner(hHero)
				this.tryStackItem(iPlayerID, iSlotPersonal)
			}
			if ( GameFunc.IsValid(hItemOldPersonal) ) {
				hItemOldPersonal.SetPurchaser(null)
				hItemOldPersonal.SetOwner(null)
				FireGameEvent("custom_item_to_public_backpack", { item = hItemOldPersonal.entindex(), player = iPlayerID })
				this.tryStackItem(iPlayerID, iSlotPublic)
			}
			return true
		}
	}
	// - @param bInv2BP boolean true:从物品栏的物品往背包拖动，反之反向
	 Inventory2BackPack(hUnit, iSlotInv, iSlotBP, bInv2BP) {
		let iPlayerID = hUnit.GetPlayerOwnerID()
		if ( type(this.tCustomBackPack[iPlayerID]) != "table" ) {
			this.tCustomBackPack[iPlayerID] = {}
		}

		let hInvItem = hUnit.GetItemInSlot(iSlotInv)
		let hBackPackItem = EntIndexToHScript((iSlotBP < PUBLIC_ITEM_SLOT_MIN && this.tCustomBackPack[iPlayerID][iSlotBP] || this.tPublicBackPack[iSlotBP]) || -1)
		if ( GameFunc.IsValid(hInvItem) || GameFunc.IsValid(hBackPackItem) ) {
			if ( GameFunc.IsValid(hBackPackItem) ) {
				if ( GameFunc.IsValid(hInvItem) && hBackPackItem.GetName() == hInvItem.GetName() ) {
					if ( (type(hBackPackItem.CanUnitPickUpIgnoreDuplicate) == "function" && !hBackPackItem.CanUnitPickUpIgnoreDuplicate(hUnit)) ) {
						return false
					}
				} else {
					if ( (type(hBackPackItem.CanUnitPickUpIgnoreEmpty) == "function" && !hBackPackItem.CanUnitPickUpIgnoreEmpty(hUnit)) ) {
						return false
					}
				}
			}

			//  两边都有同名的可叠加物品的情况处理
			if ( GameFunc.IsValid(hInvItem) && GameFunc.IsValid(hBackPackItem) ) {
				let sItemInv = hInvItem.GetName()
				let sItemBP = hBackPackItem.GetName()
				if ( sItemInv == sItemBP && hBackPackItem.IsStackable() ) {
					let iChargeTotal = hBackPackItem.GetCurrentCharges() + hInvItem.GetCurrentCharges()
					if ( bInv2BP ) {
						hBackPackItem.SetCurrentCharges(iChargeTotal)
						hInvItem.Remove()
						return true
					} else {
						hInvItem.SetCurrentCharges(iChargeTotal)
						if ( iSlotBP < PUBLIC_ITEM_SLOT_MIN ) {
							this.tCustomBackPack[iPlayerID][iSlotBP] = null
						} else {
							this.tPublicBackPack[iSlotBP] = null
						}
						hBackPackItem.Remove()
						return true
					}
				}
			}

			if ( GameFunc.IsValid(hInvItem) ) { //  物品栏到背包
				if ( !hInvItem.IsCustomShareable() ) {
					ErrorMessage(iPlayerID, "dota_hud_error_not_shareable")
					return false
				}
				if ( !hInvItem.AllowedInBackpack() ) {
					return false
				}
				hUnit.TakeItem(hInvItem)
				if ( iSlotBP < PUBLIC_ITEM_SLOT_MIN ) {
					this.tCustomBackPack[iPlayerID][iSlotBP] = hInvItem.entindex()
				} else {
					this.tPublicBackPack[iSlotBP] = hInvItem.entindex()
					hInvItem.SetPurchaser(null)
					hInvItem.SetOwner(null)
					FireGameEvent("custom_item_to_public_backpack", { item = hInvItem.entindex(), player = iPlayerID })
				}
			} else {
				if ( iSlotBP < PUBLIC_ITEM_SLOT_MIN ) {
					this.tCustomBackPack[iPlayerID][iSlotBP] = null
				} else {
					this.tPublicBackPack[iSlotBP] = null
				}
			}
			//  背包物品到物品栏
			if ( GameFunc.IsValid(hBackPackItem) ) {
				//  这个物品从公共背包来，重新设置所属者
				if ( iSlotBP >= PUBLIC_ITEM_SLOT_MIN ) {
					let hHero = PlayerResource.GetSelectedHeroEntity(iPlayerID)
					hBackPackItem.SetPurchaser(hHero)
					hBackPackItem.SetOwner(hHero)
				}

				let hResultItem = hUnit.AddItem(hBackPackItem)
				if ( GameFunc.IsValid(hResultItem) ) {
					let errorSlot = hResultItem.GetItemSlot()
					hUnit.SwapItems(iSlotInv, errorSlot)
				} else { //  这一步不应该出现，保险
					CreateItemOnPositionRandom(hUnit.GetAbsOrigin(), hBackPackItem)
				}
			}
			return true
		}

		return false
	}
	 GetItemIndexBackPack(iBackpackIndex, iPlayerID) {
		if ( iPlayerID != null && iBackpackIndex <= CUSTOM_ITEM_SLOT_MAX ) {
			if ( type(this.tCustomBackPack[iPlayerID]) != "table" ) {
				return null
			}

			return this.tCustomBackPack[iPlayerID][iBackpackIndex]
		} else if ( iBackpackIndex <= PUBLIC_ITEM_SLOT_MAX ) {
			return this.tPublicBackPack[iBackpackIndex]
		}
	}
	// - 从背包移出物品
	// - @param bDeleteEntity boolean 在移出背包的时候同时删除物品
	 RemoveItemInBackPack(iPlayerID, iSlot, bDeleteEntity) {
		if ( iSlot <= CUSTOM_ITEM_SLOT_MAX ) {
			if ( type(this.tCustomBackPack[iPlayerID]) == "table" ) {
				if ( bDeleteEntity ) {
					let hItem = EntIndexToHScript(this.tCustomBackPack[iPlayerID][iSlot] || -1)
					if ( GameFunc.IsValid(hItem) ) {
						hItem.Remove()
					}
				}
				this.tCustomBackPack[iPlayerID][iSlot] = null
				this.UpdateBackPackNettable()
			}
		} else if ( iSlot <= PUBLIC_ITEM_SLOT_MAX ) {
			if ( bDeleteEntity ) {
				let hItem = EntIndexToHScript(this.tPublicBackPack[iSlot] || -1)
				if ( GameFunc.IsValid(hItem) ) {
					hItem.Remove()
				}
			}
			this.tPublicBackPack[iSlot] = null
			this.UpdateBackPackNettable()
		}
	}
	 SellItemInBackPack(iPlayerID, iSlot, hItem) {
		if ( !(type(iSlot) == "number" && iSlot >= CUSTOM_ITEM_SLOT_MIN && iSlot <= CUSTOM_ITEM_SLOT_MAX) ) {
			return
		}
		if ( type(this.tCustomBackPack[iPlayerID]) == "table" ) {
			if ( hItem == null ) {
				hItem = EntIndexToHScript(this.tCustomBackPack[iPlayerID][iSlot] || -1)
			}

			if ( !GameFunc.IsValid(hItem) ) {
				return
			}

			if ( hItem._bIsRemaking ) {
				return
			}

			let result = this.SellItem(iPlayerID, hItem)
			if ( result == true ) {
				Items.RemoveItemInBackPack(iPlayerID, iSlot, true)
			}
			return result
		}
	}
	 SellAllInBackPack(iPlayerID) {
		if ( type(this.tCustomBackPack[iPlayerID]) == "table" ) {
			for (let iSlot = CUSTOM_ITEM_SLOT_MIN; iSlot <= CUSTOM_COMBINE_SLOT_MIN - 1 ; iSlot++) {
				this.SellItemInBackPack(iPlayerID, iSlot)
			}
		}
	}
	//  是否有空的背包 不包括合成格子
	 HasEmptyBackPack(iPlayerID) {
		if ( type(this.tCustomBackPack[iPlayerID]) != "table" ) {
			this.tCustomBackPack[iPlayerID] = {}
			return true
		}
		for (let iSlot = CUSTOM_ITEM_SLOT_MIN; iSlot <= CUSTOM_COMBINE_SLOT_MIN - 1 ; iSlot++) {
			let itemIndex = this.tCustomBackPack[iPlayerID][iSlot]
			if ( !(type(itemIndex) == "number" && GameFunc.IsValid(EntIndexToHScript(itemIndex))) ) {
				return true
			}
		}
		return false
	}
	// - 当背包新增物品时，若可堆叠，将其堆叠到可堆叠的位置
	// - @param iPlayerID number
	// - @param iSlot number 新增物品的位置
	 tryStackItem(iPlayerID, iSlot) {
		let hItem = EntIndexToHScript(this.tCustomBackPack[iPlayerID][iSlot] || -1)
		if ( iSlot >= PUBLIC_ITEM_SLOT_MIN ) {
			hItem = EntIndexToHScript(this.tPublicBackPack[iSlot] || -1)
		}
		if ( GameFunc.IsValid(hItem) && hItem.IsStackable() ) {
			let sItem = hItem.GetName()
			if ( iSlot < PUBLIC_ITEM_SLOT_MIN ) {
				for (let i = CUSTOM_ITEM_SLOT_MIN; i <= CUSTOM_COMBINE_SLOT_MIN - 1 ; i++) {
					if ( i != iSlot ) {
						let hItem2 = EntIndexToHScript(this.tCustomBackPack[iPlayerID][i] || -1)
						if ( GameFunc.IsValid(hItem2) && sItem == hItem2.GetName() ) {
							hItem2.SetCurrentCharges(hItem.GetCurrentCharges() + hItem2.GetCurrentCharges())
							hItem.Remove()
							this.tCustomBackPack[iPlayerID][iSlot] = null
							return
						}
					}
				}
			} else {
				for (let i = PUBLIC_ITEM_SLOT_MIN; i <= PUBLIC_ITEM_SLOT_MAX ; i++) {
					if ( i != iSlot ) {
						let hItem2 = EntIndexToHScript(this.tPublicBackPack[i] || -1)
						if ( GameFunc.IsValid(hItem2) && sItem == hItem2.GetName() ) {
							hItem2.SetCurrentCharges(hItem.GetCurrentCharges() + hItem2.GetCurrentCharges())
							hItem.Remove()
							this.tPublicBackPack[iSlot] = null
							return
						}
					}
				}
			}

		}
	}
}
// // // // // // // // // // // // // // // // // // // -UI事件// // // // // // // // // // // // // // // // // // // -
if ( IsServer() ) {
	 OnQuickuseConsumable(iEventSourceIndex, tEvents) {
		let hCaster = EntIndexToHScript(tEvents.caster)
		let hTarget = EntIndexToHScript(tEvents.target)
		let hItem = EntIndexToHScript(tEvents.item)
		let iPlayerID = hCaster.GetPlayerOwnerID()
		if ( tEvents.count < 0 ) {
			Service.LogPlayerCheat(iPlayerID, { where : "Quickuse", count : tEvents.count })
		}
		let iCount = math.max(0, tEvents.count)
		if ( GameFunc.IsValid(hCaster) && GameFunc.IsValid(hTarget) && GameFunc.IsValid(hItem) && hItem.GetCasterPlus() == hCaster ) {
			let iGold = PlayerData.GetGold(iPlayerID)
			let iGoldCost = hItem.GetCost()
			let iCharges = hItem.GetCurrentCharges()
			iCount = math.min(iCount, math.floor(iGold / iGoldCost) + iCharges)

			if ( hItem.OnUse != null && hItem.OnUse(hTarget, iCount) ) {
				if ( iCount >= iCharges ) {
					hItem.SetCurrentCharges(1)
					hItem.SpendCharge()
				} else {
					hItem.SetCurrentCharges(iCharges - iCount)
				}

				PlayerData.ModifyGold(iPlayerID, -iGoldCost * math.max(iCount - iCharges, 0))
			}
		}
	}
	 OnCustomRemakeItem(index, tData) {
		let iPlayerID = tData.PlayerID
		let hItem = EntIndexToHScript(tData.iItemIndex)
		if ( GameFunc.IsValid(hItem) && hItem.GetParent && hItem.GetPurchaser ) {
			let hUnit = hItem.GetParentPlus()
			if ( !GameFunc.IsValid(hUnit) ) {
				hUnit = hItem.GetPurchaser()
			}
			if ( !GameFunc.IsValid(hUnit) ) {
				return
			}
			if ( hUnit.GetPlayerOwnerID() != iPlayerID ) {
				return
			}
			if ( GameFunc.IsValid(hItem) ) {
				hItem._bIsRemaking = true
				hItem.Timer(1,  () => {
					this.RemakeItem(hItem, hUnit, iPlayerID)
					if ( GameFunc.IsValid(hItem) ) {
						hItem._bIsRemaking = false
					}
				})
			}
		}
	}
	//  合成物品 TODO:各种错误返回不同的status
	let invalid_return = { status : -1 }
	 OnCombineItem(tEvents) {
		let iPlayerID = tEvents.PlayerID
		if ( type(this.tCustomBackPack[iPlayerID]) != "table" ) {
			return invalid_return
		}
		let tItems = {}
		let iSameLevel = -1
		//  神器消耗矿金处理
		let iWoodCost = GetAbilityNameLevelSpecialValueFor("item_artifact_demagicking_maul", "wood_cost", 0)
		let bCostWood = false
		//  判断是否能合成
		for (let i = CUSTOM_COMBINE_SLOT_MIN; i <= CUSTOM_ITEM_SLOT_MAX ; i++) {
			if ( this.tCustomBackPack[iPlayerID][i] == null || this.tCustomBackPack[iPlayerID][i] == null ) {
				return invalid_return
			}
			let hItem = EntIndexToHScript(this.tCustomBackPack[iPlayerID][i])
			if ( !GameFunc.IsValid(hItem) ) {
				return invalid_return
			}
			if ( !hItem.IsCustomCombinable() ) {
				return invalid_return
			}
			if ( hItem.GetLevel() >= hItem.GetMaxUpgradeLevel() ) {
				return invalid_return
			}

			let iLevel = hItem.GetLevel()

			if ( iSameLevel == -1 ) {
				iSameLevel = iLevel
			} else if ( iSameLevel != iLevel ) {
				return invalid_return
			}
			//  第四级物品无法合成，除非拥有神器且有足够木材
			if ( iSameLevel >= 4 ) {
				if ( Artifact.PlayerHasArtifact(iPlayerID, "item_artifact_demagicking_maul") ) {
					if ( PlayerData.GetWood(iPlayerID) > iWoodCost ) {
						bCostWood = true
					} else {
						ErrorMessage(iPlayerID, "dota_hud_error_wood_not_enough")
						return invalid_return
					}
				} else {
					return invalid_return
				}
			}

			table.insert(tItems, hItem)
		}
		if ( tItems.length != 3 ) {
			return invalid_return
		}
		let rndtest = RandomFloat(0, 100)

		if ( tEvents.random ) {
			let newLevel = iSameLevel + 1
			if ( newLevel > ITEM_MAX_LEVEL ) {
				return invalid_return
			}
			let hHero = PlayerResource.GetSelectedHeroEntity(iPlayerID)
			if (  GameFunc.mathUtil.PRD(hHero, PlayerProperty.GetProperty(iPlayerID, PLAYER_PROPERTY_ITEM_COMBINE_EXLEVEL_CHANCE), 'golden_stone') ) {
				//  if ( RollPercentage(PlayerProperty.GetProperty(iPlayerID, PLAYER_PROPERTY_ITEM_COMBINE_EXLEVEL_CHANCE)) ) {
				newLevel = math.min(newLevel + 1, ITEM_MAX_LEVEL)
			}
			let result = Draw.Draw(this.tRemakeGroups["upgradable_items" + newLevel])
			if ( result == null || result == "" ) {
				return
			}

			let hNewItem = this.CreateItemWithLevel(hHero, result)
			if ( !GameFunc.IsValid(hNewItem) ) {
				return
			}

			for (let i = CUSTOM_COMBINE_SLOT_MIN; i <= CUSTOM_ITEM_SLOT_MAX ; i++) {
				this.RemoveItemInBackPack(iPlayerID, i, true)
			}

			this.tCustomBackPack[iPlayerID][CUSTOM_COMBINE_SLOT_MIN] = hNewItem.entindex()
			this.UpdateBackPackNettable()
			BpTask.UpdataTask(iPlayerID, "item_upgrade", 1)
			if ( bCostWood ) {
				PlayerData.ModifyWood(iPlayerID, -iWoodCost)
			}
			return { status = 0, combine_result = { 0 } }
		} else {
			if ( rndtest <= ChanceCombine33 ) {
				for (let i = 1; i <= 3 ; i++) {
					this.UpgradeItem(tItems[i])
				}
				BpTask.UpdataTask(iPlayerID, "item_upgrade", 1)
				if ( bCostWood ) {
					PlayerData.ModifyWood(iPlayerID, -iWoodCost)
				}
				return { status = 0, combine_result = { 0, 1, 2 } }
			} else {
				let rnd = RandomInt(1, 3)
				for (let i = 1; i <= 3 ; i++) {
					if ( i == rnd ) {
						this.UpgradeItem(tItems[i])
					} else {
						this.RemoveItemInBackPack(iPlayerID, i - 1 + CUSTOM_COMBINE_SLOT_MIN, true)
					}
				}
				BpTask.UpdataTask(iPlayerID, "item_upgrade", 1)
				if ( bCostWood ) {
					PlayerData.ModifyWood(iPlayerID, -iWoodCost)
				}
				return { status = 0, combine_result = { rnd - 1 } }
			}
		}

		return invalid_return
	}
	 OnCombineItem_lv6(index, tEvents) {
		let iPlayerID = tEvents.PlayerID
		let sItem = tEvents.recipe_item
		let bIncludingDrops = tEvents.including_drops
		let bIncludingUnSelect = tEvents.including_unselect
		let hLocalEntity = EntIndexToHScript(tEvents.local_entity)
		let tComponents = {}
		let CombineListKv = KeyValues.CombineListKv
		let CombineResult = true

		function FindItemForCombine(sItemName, iItemLevel)
			// 在选中单位身上找
			if ( GameFunc.IsValid(hLocalEntity) ) {
				for (let index = DOTA_ITEM_SLOT_1; index <= DOTA_ITEM_SLOT_9; index++) {
					let hItem = hLocalEntity.GetItemInSlot(index)
					if ( GameFunc.IsValid(hItem) ) {
						if ( hItem.GetLevel() == iItemLevel && hItem.GetAbilityName() == sItemName ) {
							return hItem
						}
					}
				}
			}
			for (let index = CUSTOM_ITEM_SLOT_MIN; index <= CUSTOM_ITEM_SLOT_MAX; index++) {
				let iItem = this.GetItemIndexBackPack(index, iPlayerID) || -1
				let hItem = EntIndexToHScript(iItem)
				if ( GameFunc.IsValid(hItem) ) {
					if ( hItem.GetLevel() == iItemLevel && hItem.GetAbilityName() == sItemName ) {
						return hItem
					}
				}
			}
			//  // 在地上找
			//  if ( !bHasItem && bIncludingDrops ) {
			//  	let array = FindAllByName(sItemName)
			//  	if ( array.GetOwner().GetPlayerOwnerID() == iPlayerID ) {
			//  		bHasItem = true
			//  		return bHasItem
			//  	}
			//  }
			// 在其他单位身上找
			//  if ( !bHasItem && bIncludingDrops ) {
			//  	let array = FindUnitsInRadius(PlayerResource.GetTeam(iPlayerID), Vector(0, 0, 0), null, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_BASIC + DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_HERO, DOTA_UNIT_TARGET_FLAGS.DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES + DOTA_UNIT_TARGET_FLAGS.DOTA_UNIT_TARGET_FLAG_OUT_OF_WORLD, FindOrder.FIND_ANY_ORDER, false)
			//  	for (let unit of ( array )) {

			//  		if ( unit != null && unit.IsAlive() && unit != hLocalEntity ) {
			//  			if ( unit.GetPlayerOwnerID() == iPlayerID ) {
			//  				if ( hLocalEntity.HasItemInInventory(sItemName) ) {
			//  					bHasItem = true
			//  					return bHasItem
			//  				}
			//  			}
			//  		}
			//  	}
			//  }
			return null
		}

		// TODO遍历配方，如果每样物品都找到，就成功合成
		for (let recipe of ( CombineListKv)) {
	 

			if ( recipe.combine_item == sItem ) {
				for (let i = 1; i <= 6; i++) {
					if ( recipe["item" + i] != null && recipe["item_star" + i] != null ) {
						//  print(recipe["item"+i], recipe["item_star"+i])
						let component = FindItemForCombine(recipe["item" + i], recipe["item_star" + i])
						//  print("count", recipe["item"+i], component.GetAbilityName())
						if ( component == null ) {
							CombineResult = false
							break
						} else {
							table.insert(tComponents, component)
						}
					}
				}
			}
		}

		if ( CombineResult ) {
			// 合成成功
			for (let hItem of ( tComponents )) {

				if ( GameFunc.IsValid(hItem) ) {
					let iSlot = hItem.GetItemSlot_Plus()
					if ( iSlot < CUSTOM_ITEM_SLOT_MIN ) {
						hLocalEntity.RemoveItem(hItem)
					} else {
						this.RemoveItemInBackPack(iPlayerID, iSlot, true)
					}
				}
			}
			this.GiveItem2Unit(hLocalEntity, sItem)
		}
	}
}
// // // // // // // // // // // // // // // // // // // -监听// // // // // // // // // // // // // // // // // // // -
 OnInventoryContentsChanged(events) {
	let hUnit = EntIndexToHScript(events.owner_index)
	if ( GameFunc.IsValid(hUnit) ) {
		if ( IsClient() ) {
			let tClientItems = {}
			for (let i = DOTA_ITEM_SLOT_1; i <= DOTA_ITEM_SLOT_9 ; i++) {
				tClientItems[i] = events["slot_" + i]
			}
			hUnit.__tClientItems = tClientItems
		}

		FireInventoryContentsChanged(hUnit)
	}
}
if ( IsServer() ) {
	 OnNPCFirstSpawned(events) {
		let spawnedUnit = EntIndexToHScript(events.entindex)
		if ( !GameFunc.IsValid(spawnedUnit) ) {
			return
		}

		if ( spawnedUnit.IsRealHero() && spawnedUnit.GetUnitLabel() == "builder" ) {
			let iPlayerID = spawnedUnit.GetPlayerOwnerID()
			this.tCustomBackPack[iPlayerID] = {}
		}
	}
	 OnEntityRemoved(tEvents) {
		let entindex = tEvents.entindex
		let hEntity = EntIndexToHScript(entindex || -1)
		if ( GameFunc.IsValid(hEntity) && hEntity.IsItem && hEntity.IsItem() ) {
			this.tItemProperties[entindex] = null
			CustomNetTables.SetTableValue("item_extra_property", tostring(entindex), null)
		}
	}
} else {
}
// // // // // // // // // // // // // // // // // // // -工具// // // // // // // // // // // // // // // // // // // -
if ( IsServer() ) {
	//  出售物品
	 SellItem(iPlayerID, hItem) {
		if ( !hItem.IsSellable() ) {
			return false
		}
		let iItemCost = hItem.GetCost()
		let iWoodCost = hItem.GetWoodCost()
		let iPointCost = GetItemPointCost(hItem.GetName())
		if ( GameRules.GetGameTime() - hItem.GetPurchaseTime() > ShopOriginalPriceTime ) {
			iItemCost = iItemCost / 2
			iWoodCost = iWoodCost * SELL_WOOD_REBACK
			iPointCost = iPointCost * SELL_POINT_REBACK
		}
		if ( hItem.IsStackable() ) {
			let coef = hItem.GetCurrentCharges() / hItem.GetInitialCharges()
			iItemCost = iItemCost * coef
			iWoodCost = iWoodCost * coef
			iPointCost = iPointCost * coef
		}
		PlayerData.ModifyGold(iPlayerID, math.floor(iItemCost), false)
		PlayerData.ModifyWood(iPlayerID, math.floor(iWoodCost), false)
		Challenge.ModifyPoint(iPlayerID, math.floor(iPointCost))
		Recycle.AddItem(iPlayerID, hItem.GetName(), hItem.GetLevel())
		return true
	}
	//  升级物品
	 UpgradeItem(hItem) {
		if ( GameFunc.IsValid(hItem) && hItem.GetLevel() < hItem.GetMaxUpgradeLevel() ) {
			//  hItem.UpgradeAbility(true) //  这种会导致闪退
			hItem.SetLevel(hItem.GetLevel() + 1)
		}
	}
	// - 重铸物品
	// - @param hItem CDOTA_Item
	 RemakeItem(hItem, hUnit, iPlayerID) {
		let hAbilityCost
		let hHero = PlayerResource.GetSelectedHeroEntity(iPlayerID)
		if ( GameFunc.IsValid(hHero) ) {
			for (let i = 1; i <= 3 ; i++) {
				let hAbility = hHero.FindAbilityByName("courier_tower_unique_" + i)
				if ( GameFunc.IsValid(hAbility) && hAbility.IsCooldownReady() ) {
					hAbilityCost = hAbility
					break
				}
			}
		}
		if ( !GameFunc.IsValid(hAbilityCost) ) {
			let iPointCost
			let RemakeEquipCost = GetKV({}, "ConfigsKV", "RemakeEquipCost")
			if ( hItem.IsHeroUniqueItem() ) {
				iPointCost = RemakeEquipCost["Unique"]
			} else {
				let iLevel = Clamp(hItem.GetLevel(), 1, ITEM_MAX_LEVEL)
				iPointCost = RemakeEquipCost[tostring(iLevel:number)]
			}

			if ( type(iPointCost) == "number" && Challenge.GetPoint(iPlayerID) >= iPointCost ) {
				Challenge.ModifyPoint(iPlayerID, -iPointCost)
			} else {
				ErrorMessage(iPlayerID, "dota_hud_error_no_remake_stone")
				return
			}
		}
		//  从同组的物品随机一个新的
		let sItem = hItem.GetName()
		let sGroup = this.tRemakeItem2Group[sItem]

		if ( hItem.IsUpgradableItem() ) { //  有等级的物品名特殊处理
			sGroup = 'upgradable_items' + hItem.GetLevel()
			sItem = sItem + "," + hItem.GetLevel()
		}

		//  神器效果重铸有概率升高稀有度
		if (  GameFunc.mathUtil.PRD(hHero, PlayerProperty.GetProperty(iPlayerID, PLAYER_PROPERTY_ITEM_REMAKE_EXLEVEL_CHANCE), 'Remake_master') ) {
			if ( hItem.IsUpgradableItem() ) {
				sGroup = 'upgradable_items' + math.min(hItem.GetLevel() + 1, ITEM_MAX_LEVEL)
				sItem = sItem + "," + math.min(hItem.GetLevel() + 1, ITEM_MAX_LEVEL)
			} else if ( string.find(sGroup, 'tower_items') ) { //  专属处理
				let tTable = {
					tower_items_SSR : 'tower_items_SSR',
					tower_items_SR : 'tower_items_SSR',
					tower_items_R : 'tower_items_SR',
				}
				sGroup = tTable[sGroup] || sGroup
			}
		}

		if ( sGroup == null ) {
			return
		}

		let tPool = deepcopy(this.tRemakeGroups[sGroup])
		tPool[sItem] = null //  不能随机到自己
		let result = Draw.Draw(tPool)
		if ( result == null || result == "" ) {
			return
		}
		//  处理当hUnit为空的情况
		let iSlot = hItem.GetItemSlot_Plus()
		if ( iSlot < CUSTOM_ITEM_SLOT_MIN ) {
			//  处理没空格的时候重铸出来的物品不掉在地上
			if ( !GameFunc.IsValid(hUnit) ) {
				hUnit = hItem.GetParentPlus()
			} else {
				hUnit.TakeItem(hItem)
			}
		} else {
			if ( !GameFunc.IsValid(hUnit) ) {
				hUnit = hItem.GetPurchaser()
			}
			if ( !GameFunc.IsValid(hUnit) && PlayerResource.IsValidPlayerID(iPlayerID) ) {
				hUnit = PlayerResource.GetSelectedHeroEntity(iPlayerID)
			}
		}
		if ( !GameFunc.IsValid(hUnit) ) {
			return
		}
		//  创建新物品
		let hNewItem = this.CreateItemWithLevel(hUnit, result)
		if ( !GameFunc.IsValid(hNewItem) ) {
			return
		}

		if ( iSlot < CUSTOM_ITEM_SLOT_MIN ) {
			let hTargetItem = hUnit.AddItem(hNewItem)
			if ( GameFunc.IsValid(hTargetItem) ) {
				hUnit.SwapItems(iSlot, hNewItem.GetItemSlot())
			} else { //  应该不会出现，保险
				CreateItemOnPositionRandom(hUnit.GetAbsOrigin(), hNewItem)
			}
		} else {
			if ( type(this.tCustomBackPack[iPlayerID]) != "table" ) {
				this.tCustomBackPack[iPlayerID] = {}
			}
			this.tCustomBackPack[iPlayerID][iSlot] = hNewItem.entindex()
			this.UpdateBackPackNettable()
		}
		let hContainer = hItem.GetContainer()
		hItem.Remove()
		if ( GameFunc.IsValid(hContainer) ) {
			hContainer.Remove()
		}

		if ( GameFunc.IsValid(hAbilityCost) ) {
			hAbilityCost.UseResources(true, true, true)
		}

		BpTask.UpdataTask(iPlayerID, "item_reforge", 1)
		return true
	}
	// - 坐标是否在共享区域
	 IsPositionInPublicArea(vPosition) {
		for (let polygon of ( this.tPublicArea)) {
	 

			if ( IsPointInPolygon(vPosition, polygon) ) {
				let tPlayerID = {}
				for (let v of ( Spawner.Spawner)) {
	 

					table.insert(tPlayerID, k)
				}
				table.sort(tPlayerID,  (a, b) => {
					return (Spawner.Spawner[a]:GetAbsOrigin() - vPosition).Length2D() < (Spawner.Spawner[b]:GetAbsOrigin() - vPosition).Length2D()
				})
				return true, tPlayerID[0]
			}
		}
		return false
	}
	// - 创建一个物品，不会直接放入背包，如果物品名是xxx，1则创建1级的物品
	// - @return CDOTA_Item 成功创建的物品或者null
	 CreateItemWithLevel(hUnit, sItemName, bPurchaseTime) {
		if ( !GameFunc.IsValid(hUnit) ) {
			return
		}
		let iLevel = 1
		if ( string.find(sItemName, ",") ) {
			let tInfo = string.split(sItemName, ",")
			sItemName = tInfo[0]
			iLevel = tonumber(tInfo[2])
		}
		let hItem = CreateItem(sItemName, hUnit, hUnit)
		if ( GameFunc.IsValid(hItem) ) {
			hItem.SetPurchaser(hUnit)
			if ( bPurchaseTime ) {
				hItem.SetPurchaseTime(GameRules.GetGameTime())
			} else {
				hItem.SetPurchaseTime(0)
			}
			//  设置物品等级
			if ( type(hItem.GetItemBaseLevel) == "function" && type(hItem.GetMaxUpgradeLevel) == "function" ) {
				let iBaseLevel = hItem.GetItemBaseLevel()
				let iMaxLevel = hItem.GetMaxUpgradeLevel()
				iLevel = Clamp(iLevel, iBaseLevel, iMaxLevel)
			}
			if ( type(iLevel:number) == "number" ) {
				hItem.SetLevel(iLevel:number)
			}

			if ( hItem.GetParentPlus() == hUnit ) {
				hUnit.TakeItem(hItem)
			}
			return hItem
		}
	}
	// - 创建物品给一个单位
	// - @return CDOTA_Item
	 GiveItem2Unit(hUnit, sItemName, bPurchaseTime) {
		if ( !GameFunc.IsValid(hUnit) ) {
			return
		}
		let hItem = this.CreateItemWithLevel(hUnit, sItemName, bPurchaseTime)
		if ( GameFunc.IsValid(hItem) ) {
			let hTargetItem = hUnit.AddItem(hItem)
			if ( GameFunc.IsValid(hTargetItem) ) {
				hItem = hTargetItem
			} else {
				CreateItemOnPositionRandom(hUnit.GetAbsOrigin(), hItem)
			}
			return hItem
		}
	}
	// - 创建物品到玩家背包
	// - @param iPlayerID number
	// - @param item string | CDOTA_Item
	// - @param bPurchaseTime boolean
	 GiveItem2PlayerBackPack(iPlayerID, item, bPurchaseTime) {
		if ( !PlayerResource.IsValidPlayerID(iPlayerID) ) {
			return
		}

		if ( type(this.tCustomBackPack[iPlayerID]) != "table" ) {
			this.tCustomBackPack[iPlayerID] = {}
		}

		let sItem = item
		let hItem = item
		if ( type(sItem) == "string" ) {
			let hHero = PlayerResource.GetSelectedHeroEntity(iPlayerID)
			if ( !GameFunc.IsValid(hHero) ) {
				return
			}
			hItem = this.CreateItemWithLevel(hHero, sItem, bPurchaseTime)
		} else {
			sItem = hItem.GetName()
		}

		if ( GameFunc.IsValid(hItem) ) {
			for (let iSlot = CUSTOM_ITEM_SLOT_MIN; iSlot <= CUSTOM_COMBINE_SLOT_MIN - 1 ; iSlot++) {
				if ( this.tCustomBackPack[iPlayerID][iSlot] == null ) {
					if ( hItem.IsCastOnPickup() ) {
						hItem.OnSpellStart()
					} else {
						this.tCustomBackPack[iPlayerID][iSlot] = hItem.entindex()
						this.tryStackItem(iPlayerID, iSlot)
						this.UpdateBackPackNettable()
					}
					return hItem
				}
			}
			//  没有空位，放到购买者身上或者地上
			let hHero = PlayerResource.GetSelectedHeroEntity(iPlayerID)
			if ( !GameFunc.IsValid(hHero) ) {
				return
			}
			let hTargetItem = hHero.AddItem(hItem)
			if ( !GameFunc.IsValid(hTargetItem) ) {
				CreateItemOnPositionRandom(hHero.GetAbsOrigin(), hItem)
				ErrorMessage(iPlayerID, "dota_hud_error_item_to_hero_around")
			} else {
				ErrorMessage(iPlayerID, "dota_hud_error_item_to_hero_slot")
			}
			return hItem
		}
	}
	// - 将单位身上的物品替换成另一个
	// - @param hUnit CDOTA_BaseNPC
	// - @param hOldItem CDOTA_Item
	// - @param sNewItem string
	 ReplaceItem(hUnit, hOldItem, sNewItem) {
		let iSlot = hOldItem.GetItemSlot()
		let hNewItem = this.CreateItemWithLevel(hUnit, sNewItem)
		if ( GameFunc.IsValid(hNewItem) ) {
			hUnit.RemoveItem(hOldItem)
			let hResultItem = hUnit.AddItem(hNewItem)
			if ( GameFunc.IsValid(hResultItem) ) {
				if ( hNewItem.GetItemSlot() != iSlot ) {
					hUnit.SwapItems(hNewItem.GetItemSlot(), iSlot)
				}
			} else {
				CreateItemOnPositionRandom(hUnit.GetAbsOrigin(), hNewItem)
			}
		}
	}
}
// =======================================物品额外随机属性=======================================
if ( IsServer() ) {
	// - 给物品随机额外属性
	// - @param hItem CDOTA_Item
	 RandomItemExtraProperties(hItem, iNum) {
		if ( iNum == null ) {
			iNum = 8
		}

		let iIndex = hItem.entindex()
		this.tItemProperties[iIndex] = {}

		let tPool = WeightPool(deepcopy(KeyValues.tItemPropertyWeight))
		let tSum = {}
		for (let i = 1; i <= iNum ; i++) {
			let sProperty = tPool.Random()
			let config = KeyValues.ItemExtraProperty[sProperty]
			if ( config == null ) {
				return false
			}

			let fValue = math.boxMullerRandom(config.min, config.max)
			table.insert(this.tItemProperties[iIndex], { sProperty = sProperty, fValue = fValue })

			//  不超过最高数量
			tSum[sProperty] = (tSum[sProperty] || 0) + 1
			if ( tSum[sProperty] >= config.max_count ) {
				tPool.Remove(sProperty)
			}
		}
		CustomNetTables.SetTableValue("item_extra_property", tostring(iIndex), this.tItemProperties[iIndex])
		hItem.GameTimer(0.2,  () => {
			let hParent = hItem.GetParentPlus()
			if ( GameFunc.IsValid(hParent) ) {
				hParent.FireOnInventoryContentsChanged()
			}
		})
		return true
	}
}
return Items